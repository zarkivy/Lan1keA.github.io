<!DOCTYPE html>
<html lang="zh"><head>
    <meta charset="UTF-8">
    <title>ã‚„ã‚Œã‚„ã‚Œ DAâœ°ZE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="ä»¥åŠCVE-2022-30552" />
    <meta property="og:title" content="å¯¹U-Boot CVE-2022-30790çš„è·Ÿè¸ª" />
    <meta property="og:description" content="ä»¥åŠCVE-2022-30552" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://cerr.cc/post/cve-2022-30790/" />
    <meta itemprop="name" content="å¯¹U-Boot CVE-2022-30790çš„è·Ÿè¸ª">
    <meta itemprop="description" content="ä»¥åŠCVE-2022-30552">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
    
    <link rel="stylesheet" href="https://cerr.cc/scss/style.min.8cf7a5758f9d406f171a1184f6b6ec0a6175c7d809e6dd601dd4878d8acf96b1.css" >
</head>
<body>
    <header>
    <div class="header header-frame">
        <div>
          
            <h1 class="header__title">å¯¹U-Boot CVE-2022-30790çš„è·Ÿè¸ª</h1>
          
            
                <div class="header__description">ä»¥åŠCVE-2022-30552</div>
            
        </div>
        <nav class="header-nav">
            <ul class="header-nav-list header-nav-list--menu">
                
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/about/">
                                
                                <span>About</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/board/">
                                
                                <span>Board</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/flink/">
                                
                                <span>Flink</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/utils/">
                                
                                <span>Utils</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/love/">
                                
                                <span>Love</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/ilus/">
                                
                                <span>Ilus</span>
                            </a>
                        </li>
                    
                
            </ul>
            <button class="header-nav-list__nav-btn">~#</button>
        </nav>
        <button class="mb-header__menu-btn">
            <span class="mb-header__menu-btn-line"></span>
            <span class="mb-header__menu-btn-line"></span>
            <span class="mb-header__menu-btn-line"></span>
        </button>
    </div>
    <nav id="mobile-header-nav" class="mb-header-nav">
  
  
  <button class="mb-header-nav__close-btn flex-center">
    <svg
            class="mb-header-nav__svg-icon"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            width="32"
            height="32"
            >
            <path
                d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
                />
            <path d="M0 0h24v24H0z" fill="none" />
        </svg>
    </button>
    
    <div class="mb-header-nav__wrapper">
        <div class="mb-header-nav__container">
            <svg
                width="240"
                height="72"
                viewBox="0 0 240 72"
                class="mb-header-nav__title"
                >
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">
                Tags
                </text>
            </svg>
            <ul class="mb-header-nav-list">
                
                    
                        
                          <li class="mb-header-nav-list__item ">
                        <a class="mb-header-nav-list__link" href="https://cerr.cc/tags/vulnerability/"
                                                            >Vulnerability</a
                                                        >
                    </li>
                        
                    
                
            </ul>
        </div>
        <div class="mb-header-nav__container">
            <svg
                width="240"
                height="72"
                viewBox="0 0 240 72"
                class="mb-header-nav__title"
                >
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">
                Menu
                </text>
            </svg>
            <ul class="mb-header-nav-list">
                
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/about/">
                                About
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/board/">
                                Board
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/flink/">
                                Flink
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/utils/">
                                Utils
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/love/">
                                Love
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/ilus/">
                                Ilus
                            </a>
                        </li>
                    
                
            </ul>
        </div>
    </div>
</nav>

</header>



    <div id="content">
<article class="post">
  
    <div class="post-content"><h1 id="u-booté€Ÿè§ˆ">U-Booté€Ÿè§ˆ</h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Das_U-Boot">Das U-Boot - Wikipedia</a></li>
<li><a href="https://github.com/u-boot/u-boot">https://github.com/u-boot/u-boot</a></li>
<li><a href="https://elixir.bootlin.com/u-boot/latest/source">U-Bootæºç åœ¨çº¿æµè§ˆ</a></li>
</ul>
<h1 id="æ‘ä¸­ä¼ è¨€">æ‘ä¸­ä¼ è¨€</h1>
<p><strong><a href="https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/">https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/</a></strong></p>
<p>ğŸ¤”Hmmm&hellip;æ–°é²œæ¼æ´ï¼Œæ²¡æœ‰PoCã€‚è¿™æ¬¡æ˜¯å‡ºäº†ä¸¤ä¸ªæ¼æ´ï¼Œåˆ†åˆ«æ˜¯ï¼š</p>
<ul>
<li>Hole Descriptor Overwrite in U-Boot IP Packet Defragmentation Leads to Arbitrary Out of Bounds Write Primitive (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30790">CVE-2022-30790</a>)</li>
<li>Large buffer overflow leads to DoS in U-Boot IP Packet Defragmentation Code (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30552">CVE-2022-30552</a>)</li>
</ul>
<p>å…ˆæ¥åˆ†æåˆ†æå‡ºç°æ¼æ´çš„æºç ã€‚æ ¹æ®ï¼š</p>
<blockquote>
<p><strong>May 18th 2022:</strong> Initial e-mail from NCC to U-boot maintainers announcing two vulnerabilities were identified.</p>
</blockquote>
<p>é‚£ä¹ˆç”¨U-Boot v2022.04è·Ÿè¸ªæ¼æ´åº”è¯¥æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚</p>
<h1 id="æ¼æ´æºç åˆ†æ">æ¼æ´æºç åˆ†æ</h1>
<h2 id="cve-2022-30790">CVE-2022-30790</h2>
<p>æ¼æ´å½±å“ï¼š</p>
<blockquote>
<p>The U-Boot implementation of <a href="https://datatracker.ietf.org/doc/html/rfc815">RFC815</a> IP DATAGRAM REASSEMBLY ALGORITHMS is susceptible to a Hole Descriptor overwrite attack which ultimately leads to an arbitrary write primitive.</p>
</blockquote>
<h3 id="rfc815">RFC815</h3>
<p>çœ‹æ¥éœ€è¦å…ˆäº†è§£ä¸‹RFC815çš„IPv4åˆ†ç‰‡ç®—æ³•ï¼š</p>
<ul>
<li>åŸæ–‡æ¡£ï¼š<a href="https://datatracker.ietf.org/doc/html/rfc815">https://datatracker.ietf.org/doc/html/rfc815</a></li>
<li>ä¸€ç¯‡ç›¸å…³è®ºæ–‡ï¼š<a href="http://www.ecice06.com/CN/Y2008/V34/I22/100">http://www.ecice06.com/CN/Y2008/V34/I22/100</a></li>
</ul>
<blockquote>
<p>RFC815 æ˜¯ IETF æ¨èçš„ä¸€ç§åˆ†ç‰‡é‡ç»„ç®—æ³•ï¼Œè¯¥ç®—æ³•å…·æœ‰è®°å½•åˆ†ç‰‡ç®€æ´ï¼Œå†…å­˜éœ€æ±‚é‡ä¸åŸ IPv4 æ•°æ®æŠ¥å¤§å°ä¸€è‡´ç­‰ä¼˜ç‚¹ã€‚</p>
</blockquote>
<p>è¯¥ç®—æ³•çš„ä½œç”¨å¯¹è±¡æ˜¯IPv4æ•°æ®æŠ¥ã€‚IPv4æ•°æ®æŠ¥çš„Headerç»“æ„å¦‚ä¸‹ï¼š(ref - <a href="https://en.wikipedia.org/wiki/IPv4">https://en.wikipedia.org/wiki/IPv4</a></p>
<p><img src="https://s2.loli.net/2022/06/16/nlCgH1URZ7uXwQ3.png" alt="image.png"></p>
<p>å…¶ä¸­ï¼Œåˆ†ç‰‡ä¿¡æ¯è®°å½•åœ¨ï¼š</p>
<ul>
<li>
<p><strong>Identification</strong></p>
<ul>
<li>This field is an identification field and is primarily used for uniquely identifying the group of fragments of a single IP datagram. Some experimental work has suggested using the ID field for other purposes, such as for adding packet-tracing information to help trace datagrams with spoofed source addresses, but RFC 6864 now prohibits any such use.</li>
</ul>
</li>
<li>
<p><strong>Flags</strong></p>
<ul>
<li>
<p>A three-bit field follows and is used to control or identify fragments. They are (in order, from most significant to least significant):</p>
<ul>
<li>bit 0: Reserved; must be zero</li>
<li>bit 1: Don&rsquo;t Fragment (DF)</li>
<li>bit 2: More Fragments (MF)</li>
</ul>
<p>If the DF flag is set, and fragmentation is required to route the packet, then the packet is dropped. This can be used when sending packets to a host that does not have resources to perform reassembly of fragments. It can also be used for <a href="https://en.wikipedia.org/wiki/Path_MTU_discovery">path MTU discovery</a>, either automatically by the host IP software, or manually using diagnostic tools such as <a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a> or <a href="https://en.wikipedia.org/wiki/Traceroute">traceroute</a>.</p>
<p>For unfragmented packets, the MF flag is cleared. For fragmented packets, all fragments except the last have the MF flag set. The last fragment has a non-zero Fragment Offset field, differentiating it from an unfragmented packet.</p>
</li>
</ul>
</li>
<li>
<p><strong>Fragment Offset</strong></p>
<ul>
<li>This field specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram <strong>in units of eight-byte blocks</strong>. The first fragment has an offset of zero. The 13 bit field allows a maximum offset of (2<sup>13</sup> â€“ 1) Ã— 8 = 65,528 bytes, which, with the header length included (65,528 + 20 = 65,548 bytes), supports fragmentation of packets exceeding the maximum IP length of 65,535 bytes.</li>
</ul>
</li>
</ul>
<p>æ³¨æ„åˆ°åˆ†ç‰‡çš„ç´¢å¼•å•ä½ä¸º8å­—èŠ‚ã€‚</p>
<p>å¥½äº†ï¼Œç®€å•äº†è§£è¿‡æ•°æ®ç»“æ„ï¼Œæ¥ç€æ¥çœ‹çœ‹ç®—æ³•ã€‚</p>
<p>åŸæ–‡æ¡£æœ‰è¨€ï¼š</p>
<blockquote>
<p>One of the mechanisms of IP is fragmentation and reassembly.</p>
<p>åˆ†ç‰‡å’Œé‡ç»„æ˜¯IPv4åè®®çš„ä¸€ä¸ªæœºåˆ¶ã€‚(æ–‡æ¡£å¾ˆè€ï¼Œé‚£æ—¶è¿˜æ²¡æœ‰IPv6ã€‚In contrast, <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a>, the next generation of the Internet Protocol, does not allow routers to perform fragmentation; hosts must perform <a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">Path MTU Discovery</a> before sending datagrams.)</p>
</blockquote>
<blockquote>
<p>A  datagram originally transmitted as a single unit will arrive at its final destination broken into several fragments.</p>
<p>ä¸€ä¸ªæ•°æ®æŠ¥â€”â€”ä½œä¸ºä¼ è¾“åŸºæœ¬å•å…ƒï¼Œä¼šè¢«åˆ‡åˆ†ä¸ºå¤šä¸ªåˆ†ç‰‡é€è¾¾æœ€ç»ˆçš„ç›®çš„åœ°ã€‚</p>
</blockquote>
<p>è€ŒRFC815æ‰€å®šä¹‰çš„ï¼Œæ­£æ˜¯<strong>reassemblyâ€”â€”åˆ†ç‰‡é‡ç»„</strong>è¿™ä¸€æ­¥çš„å…·ä½“å®ç°ç®—æ³•ã€‚</p>
<blockquote>
<p>In  order  to  define this reassembly algorithm, it is necessary to define some terms.</p>
<p>A partially reassembled datagram consists of certain sequences of octets that have already arrived, and certain  areas  still to  come.</p>
</blockquote>
<blockquote>
<p>We will refer to these missing areas as <strong>&ldquo;holes&rdquo;</strong>.</p>
<p>Each hole can be characterized by two numbers:</p>
<ul>
<li><strong>hole.first</strong>
<ul>
<li>the number of the first octet in the hole</li>
</ul>
</li>
<li><strong>hole.last</strong>
<ul>
<li>the number of the last  octet  in  the hole</li>
</ul>
</li>
</ul>
<p>This pair of numbers we will call the <strong>&ldquo;hole descriptor&rdquo;</strong>,</p>
<p>and we will assume that all of the hole descriptors for a  particular  datagram are gathered together in the <strong>&ldquo;hole descriptor list&rdquo;</strong>.</p>
</blockquote>
<p>æ€»ä½“æ¥è¯´:</p>
<blockquote>
<p>The  general  form  of  the  algorithm  is  as follows.</p>
<p>When a new fragment of the datagram arrives, it will possibly fill in one  or  more of  the existing holes.</p>
<p>We will examine each of the entries in the hole descriptor list to see whether the hole in  question  is  eliminated  by this incoming fragment.</p>
<p>If so, we will delete that entry from the list.</p>
<p>Eventually, a fragment will arrive which eliminates every entry from the list.</p>
<p>At this point, the datagram has been completely reassembled and can be passed to higher protocol levels for further processing.</p>
</blockquote>
<p>å…·ä½“çš„ç®—æ³•å®ç°è¦åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š</p>
<p>é¦–å…ˆæ˜¯<strong>Fragment Processing Algorithm</strong></p>
<blockquote>
<p>We  start  the algorithm when the earliest fragment of the datagram arrives.  We begin by creating an empty data buffer area and putting one entry in its  hole  descriptor  list,  the  entry  which  describes  the datagram  as  being completely missing.  In this case, hole.first equals zero, and hole.last equals infinity. (Infinity is presumably implemented by a very large integer, greater than 576, of the implementor&rsquo;s choice.) The following eight steps are then used to insert each of  the  arriving fragments  into  the  buffer  area  where the complete datagram is being built up.  The arriving fragment is  described  by  fragment.first,  the first  octet  of  the fragment, and fragment.last, the last octet of the fragment.</p>
</blockquote>
<p>æ¥ç€è¿›è¡Œå¦‚ä¸‹æµç¨‹ï¼š</p>
<ol>
<li>Select the next hole  descriptor  from  the  hole  descriptor list.  If there are no more entries, go to step eight.</li>
<li>If fragment.first is greater than hole.last, go to step one.</li>
<li>If fragment.last is less than hole.first, go to step one.</li>
<li>Delete the current entry from the hole descriptor list.</li>
<li>If fragment.first is greater than hole.first, then  create  a new  hole  descriptor &ldquo;new_hole&rdquo; with new_hole.first equal to hole.first, and new_hole.last equal to  fragment.first  minus one.</li>
<li>If fragment.last is less  than  hole.last  and  fragment.more fragments   is  true,  then  create  a  new  hole  descriptor &ldquo;new_hole&rdquo;, with new_hole.first equal to  fragment.last  plus one and new_hole.last equal to hole.last.</li>
<li>Go to step one.</li>
<li>If the hole descriptor list is now empty, the datagram is now complete.  Pass it on to the higher level protocol  processor for further handling. Otherwise, return.</li>
</ol>
<p>ç®—æ³•çš„ç¬¬äºŒéƒ¨åˆ†æ˜¯<strong>Managing the Hole Descriptor List</strong></p>
<p>å…¶ä¸­æœ‰è§„åˆ™ï¼š</p>
<blockquote>
<p>Just put each hole descriptor in the first octets of  the  hole  itself.</p>
<p>å°†holeçš„æè¿°ç¬¦ç½®äºholeçš„å‰å…«ä¸ªå­—èŠ‚ä½ç½®å³å¯ã€‚</p>
<p>Note  that by the definition of the reassembly algorithm, the minimum size of  a  hole  is  eight  octets.</p>
<p>To  store hole.first  and  hole.last  will presumably require two octets each.</p>
<p>An additional two octets will be required to thread together the entries on the hole descriptor list.</p>
<p>This leaves at least two more octets to  dealwith implementation idiosyncrasies.</p>
</blockquote>
<p>holeçš„æœ€å°å¤§å°æ˜¯8å­—èŠ‚ã€‚å¤§å°å’ŒU-Bootçš„å®ç°æ˜¯å¥‘åˆçš„ï¼š</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * this is the packet being assembled, either data or frag control.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * Fragments go by 8 bytes, so this union must be 8 bytes long
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> hole {
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* first_byte is address of this structure */</span>
</span></span><span style="display:flex;"><span>	u16 last_byte;	<span style="color:#998;font-style:italic">/* last byte in this hole + 1 (begin of next hole) */</span>
</span></span><span style="display:flex;"><span>	u16 next_hole;	<span style="color:#998;font-style:italic">/* index of next (in 8-b blocks), 0 == none */</span>
</span></span><span style="display:flex;"><span>	u16 prev_hole;	<span style="color:#998;font-style:italic">/* index of prev, 0 == none */</span>
</span></span><span style="display:flex;"><span>	u16 unused;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>ä½†å†…å®¹æœ‰äº›ä¸åŒï¼šU-Bootçš„å®ç°å¹¶ä¸åŒ…å«<code>hole.first</code>åŸŸï¼Œå› ä¸º first_byte is address of this structure.</p>
<p>ç”±æ­¤çœ‹æ¥ï¼Œè¿™é‡Œçš„å†…å­˜ç®¡ç†æ–¹å¼ç±»ä¼¼äºGlibcå †å†…å­˜ç®¡ç†æ–¹æ¡ˆã€‚ç”¨åŒå‘é“¾è¡¨ç®¡ç†äº†ç©ºé—²åŒºåŸŸï¼ˆholeã€free chunkï¼‰ï¼Œä¸”åœ¨ç©ºé—²åŒºåŸŸå†…éƒ¨è®°å½•è‡ªå·±çš„ç›¸å…³ä¿¡æ¯ï¼Œæœ€å°å¤§å°ä¸ºè‡ªèº«æ§åˆ¶åŸŸï¼ˆ8-Bytes struct holeã€free chunk headerï¼‰ï¼Œå¹¶ç»„æˆåŒå‘é“¾è¡¨ç”¨äºé«˜æ•ˆæ£€ç´¢ã€‚ä½†ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œholeä¹‹é—´ç»„æˆçš„é“¾è¡¨ï¼Œæ˜¯å€Ÿç”±å­—èŠ‚ç´¢å¼•è€ŒéæŒ‡é’ˆå®ç°çš„ã€‚</p>
<h3 id="å¼€å§‹åˆ†æ">å¼€å§‹åˆ†æ</h3>
<p>æ¼æ´ä½ç½®ï¼š</p>
<blockquote>
<p>In <code>u-boot/net/net.c</code> the <code>__net_defragment</code> function line 900 through 1018.</p>
</blockquote>
<p>æ¼æ´æºç ï¼š</p>
<p><a href="https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900">https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900</a></p>
<p>defragmentå³reassemblyçš„æ“ä½œï¼Œåˆå¹¶åˆ†ç‰‡ã€‚æ³¨é‡Šä¸åˆ†æå¦‚ä¸‹ï¼š</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">static</span> <span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">__net_defragment</span>(<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>ip, <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>lenp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">static</span> uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN); <span style="color:#998;font-style:italic">// packet_buffer ip_packet_size packet_align
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">static</span> u16 first_hole, total_len;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">struct</span> hole <span style="color:#000;font-weight:bold">*</span>payload, <span style="color:#000;font-weight:bold">*</span>thisfrag, <span style="color:#000;font-weight:bold">*</span>h, <span style="color:#000;font-weight:bold">*</span>newh; <span style="color:#998;font-style:italic">// payload this_fragment hole new_hole
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>localip <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>)pkt_buff;
</span></span><span style="display:flex;"><span>	uchar <span style="color:#000;font-weight:bold">*</span>indata <span style="color:#000;font-weight:bold">=</span> (uchar <span style="color:#000;font-weight:bold">*</span>)ip;
</span></span><span style="display:flex;"><span>	<span style="color:#458;font-weight:bold">int</span> offset8, start, len, done <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>	u16 ip_off <span style="color:#000;font-weight:bold">=</span> ntohs(ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_off);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* payload starts after IP header, this fragment is in there */</span>
</span></span><span style="display:flex;"><span>	payload <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> hole <span style="color:#000;font-weight:bold">*</span>)(pkt_buff <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>	offset8 <span style="color:#000;font-weight:bold">=</span>  (ip_off <span style="color:#000;font-weight:bold">&amp;</span> IP_OFFS); <span style="color:#998;font-style:italic">// IP_OFFS 0x1fff 0b0001111111111111ï¼Œåˆ†ç‰‡ç´¢å¼•çš„åŸºæœ¬å•ä½ä¸º8å­—èŠ‚
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	thisfrag <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> offset8; <span style="color:#998;font-style:italic">// å½“å‰åˆ†ç‰‡çš„ç´¢å¼•ï¼ˆ8å­—èŠ‚ï¼‰
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	start <span style="color:#000;font-weight:bold">=</span> offset8 <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">8</span>; <span style="color:#998;font-style:italic">// å½“å‰åˆ†ç‰‡çš„å­—èŠ‚ç´¢å¼•
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	len <span style="color:#000;font-weight:bold">=</span> ntohs(ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_len) <span style="color:#000;font-weight:bold">-</span> IP_HDR_SIZE; <span style="color:#998;font-style:italic">// æ”»å‡»è€…é€šè¿‡æ„é€ æ¶æ„æ•°æ®åŒ…ï¼Œå°†ip-&gt;ip_lenæ§åˆ¶åœ¨21~27ï¼Œä½¿å¾—lenä¸º1~7çš„å€¼ï¼Œè§¦å‘åç»­æ¼æ´
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (start <span style="color:#000;font-weight:bold">+</span> len <span style="color:#000;font-weight:bold">&gt;</span> IP_MAXUDP) <span style="color:#998;font-style:italic">/* fragment extends too far */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>total_len <span style="color:#000;font-weight:bold">||</span> localip<span style="color:#000;font-weight:bold">-&gt;</span>ip_id <span style="color:#000;font-weight:bold">!=</span> ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_id) { <span style="color:#998;font-style:italic">// group of fragments of a single IP datagramä¸åŒï¼Œæ„å‘³ç€æ–°æ¥çš„åˆ†ç‰‡ä¸å±äºåŒä¸€æ•°æ®æŠ¥
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">/* new (or different) packet, reset structs */</span>
</span></span><span style="display:flex;"><span>		total_len <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0xffff</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].last_byte <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">~</span><span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].next_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].prev_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		first_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* any IP header will work, copy the first we received */</span>
</span></span><span style="display:flex;"><span>		memcpy(localip, ip, IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// æ­¤åå°±æ˜¯å…·ä½“çš„reassemblyç®—æ³•å®ç°äº†
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * What follows is the reassembly algorithm. We use the payload
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * array as a linked list of hole descriptors, as each hole starts
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * at a multiple of 8 bytes. However, last byte can be whatever value,
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * so it is represented as byte count, not as 8-byte blocks.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	h <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> first_hole;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">while</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;</span> start) {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* no hole that far away */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		h <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* last fragment may be 1..7 bytes, the &#34;+7&#34; forces acceptance */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (offset8 <span style="color:#000;font-weight:bold">+</span> ((len <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">7</span>) <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>) <span style="color:#000;font-weight:bold">&lt;=</span> h <span style="color:#000;font-weight:bold">-</span> payload) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* no overlap with holes (dup fragment?) */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>(ip_off <span style="color:#000;font-weight:bold">&amp;</span> IP_FLAGS_MFRAG)) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* no more fragmentss: truncate this (last) hole */</span>
</span></span><span style="display:flex;"><span>		total_len <span style="color:#000;font-weight:bold">=</span> start <span style="color:#000;font-weight:bold">+</span> len;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start <span style="color:#000;font-weight:bold">+</span> len;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * There is some overlap: fix the hole list. This code doesn&#39;t
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * deal with a fragment that overlaps with two different holes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * (thus being a superset of a previously-received fragment).
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> ((h <span style="color:#000;font-weight:bold">&gt;=</span> thisfrag) <span style="color:#000;font-weight:bold">&amp;&amp;</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;=</span> start <span style="color:#000;font-weight:bold">+</span> len)) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* complete overlap with hole: remove hole */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole <span style="color:#000;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* last remaining hole */</span>
</span></span><span style="display:flex;"><span>			done <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* first hole */</span>
</span></span><span style="display:flex;"><span>			first_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* last hole */</span>
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* in the middle of the list */</span>
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole;
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;=</span> start <span style="color:#000;font-weight:bold">+</span> len) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* overlaps with final part of the hole: shorten this hole */</span>
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (h <span style="color:#000;font-weight:bold">&gt;=</span> thisfrag) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* overlaps with initial part of the hole: move this hole */</span>
</span></span><span style="display:flex;"><span>		newh <span style="color:#000;font-weight:bold">=</span> thisfrag <span style="color:#000;font-weight:bold">+</span> (len <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>); <span style="color:#998;font-style:italic">// è®¡ç®—new_holeçš„åˆ†ç‰‡ç´¢å¼•å€¼ã€‚lenä¸º1~7çš„å€¼æ—¶ï¼Œä¼šå¯¼è‡´æ­¤å¤„ newh == thisfrag
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#000;font-weight:bold">*</span>newh <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>h;
</span></span><span style="display:flex;"><span>		h <span style="color:#000;font-weight:bold">=</span> newh;
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole)
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole)
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>			first_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* fragment sits in the middle: split the hole */</span>
</span></span><span style="display:flex;"><span>		newh <span style="color:#000;font-weight:bold">=</span> thisfrag <span style="color:#000;font-weight:bold">+</span> (len <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">*</span>newh <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>h;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole <span style="color:#000;font-weight:bold">=</span> (newh <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		newh<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (newh<span style="color:#000;font-weight:bold">-&gt;</span>next_hole)
</span></span><span style="display:flex;"><span>			payload[newh<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> (newh <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* finally copy this fragment and possibly return whole packet */</span>
</span></span><span style="display:flex;"><span>	memcpy((uchar <span style="color:#000;font-weight:bold">*</span>)thisfrag, indata <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE, len); <span style="color:#998;font-style:italic">/* è¿™é‡Œå‘this_fragmentä¸­å†™å…¥æ”»å‡»è€…å¯æ§çš„æ•°æ®ï¼Œ
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">							ä½†ç”±äº newh == thisfragï¼Œé€ æˆnew_holeä¸­çš„æ§åˆ¶æ•°æ®è¢«ç¯¡æ”¹ï¼ˆç±»ä¼¼äºfree chunk headerè¢«ç¯¡æ”¹ï¼‰ã€‚
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">							ä¸”å½“lenä¸º6æ—¶ï¼Œfirst_holeä¸­çš„last_byteã€next_holeã€prev_holeéƒ½è¢«æ”»å‡»è€…æ§åˆ¶ï¼Œ
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">							ç”±æ­¤ï¼Œæ”»å‡»è€…é€šè¿‡åŠ«æŒholeçš„ä½ç½®ç´¢å¼•ï¼Œé€ æˆä»»æ„åœ°å€å†™ã€‚*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>done)
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	localip<span style="color:#000;font-weight:bold">-&gt;</span>ip_len <span style="color:#000;font-weight:bold">=</span> htons(total_len);
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">*</span>lenp <span style="color:#000;font-weight:bold">=</span> total_len <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> localip;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>æ‰€ä»¥å®é™…ä¸Šæ˜¯ä¸€ä¸ªï¼šç›²ç›®ä¿¡ä»»ç”¨æˆ·ä¼ å…¥çš„IPæ•°æ®æŠ¥ä¸­çš„<code>ip_len</code>å­—æ®µï¼Œé€ æˆholeç»“æ„è¢«åŠ«æŒï¼Œè€Œå¯¼è‡´çš„æ•°ç»„è¶Šç•Œå†™æ¼æ´ã€‚</p>
<p>ç”±æ­¤è¾¾æˆçš„ä»»æ„åœ°å€å†™å¯ä»¥ç”¨äºrootæœ¬åœ°è®¾å¤‡ã€‚ä½†ç”±äºè·¯ç”±å™¨å¾€å¾€ä¼šå¯¹ç»è¿‡è‡ªå·±çš„æ•°æ®åŒ…åˆæ³•æ€§åšæ ¡éªŒå¹¶ä¸¢å¼ƒéæ³•æ•°æ®æŠ¥ï¼Œå¯¼è‡´æ­¤æ¼æ´éš¾ä»¥äºäº’è”ç½‘ä¸Šåˆ©ç”¨ã€‚</p>
<h2 id="cve-2022-30552">CVE-2022-30552</h2>
<p>æ¼æ´å‡ºç°ä½ç½®å’Œä¸Šä¸ªæ¼æ´ç›¸åŒ</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">static</span> <span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">__net_defragment</span>(<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>ip, <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>lenp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">static</span> uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN);
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">static</span> u16 first_hole, total_len;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">struct</span> hole <span style="color:#000;font-weight:bold">*</span>payload, <span style="color:#000;font-weight:bold">*</span>thisfrag, <span style="color:#000;font-weight:bold">*</span>h, <span style="color:#000;font-weight:bold">*</span>newh;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>localip <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>)pkt_buff;
</span></span><span style="display:flex;"><span>	uchar <span style="color:#000;font-weight:bold">*</span>indata <span style="color:#000;font-weight:bold">=</span> (uchar <span style="color:#000;font-weight:bold">*</span>)ip;
</span></span><span style="display:flex;"><span>	<span style="color:#458;font-weight:bold">int</span> offset8, start, len, done <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>	u16 ip_off <span style="color:#000;font-weight:bold">=</span> ntohs(ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_off);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* payload starts after IP header, this fragment is in there */</span>
</span></span><span style="display:flex;"><span>	payload <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> hole <span style="color:#000;font-weight:bold">*</span>)(pkt_buff <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>	offset8 <span style="color:#000;font-weight:bold">=</span>  (ip_off <span style="color:#000;font-weight:bold">&amp;</span> IP_OFFS);
</span></span><span style="display:flex;"><span>	thisfrag <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> offset8;
</span></span><span style="display:flex;"><span>	start <span style="color:#000;font-weight:bold">=</span> offset8 <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">8</span>;
</span></span><span style="display:flex;"><span>	len <span style="color:#000;font-weight:bold">=</span> ntohs(ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_len) <span style="color:#000;font-weight:bold">-</span> IP_HDR_SIZE; <span style="color:#998;font-style:italic">// ip-&gt;ip_lenç”±æ”»å‡»è€…æ§åˆ¶ï¼Œå°†å…¶è®¾å®šä¸ºå°äºIP_HDR_SIZEçš„å€¼ä¼šä½¿å¾—lenä¸ºè´Ÿå€¼
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (start <span style="color:#000;font-weight:bold">+</span> len <span style="color:#000;font-weight:bold">&gt;</span> IP_MAXUDP) <span style="color:#998;font-style:italic">/* fragment extends too far */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>total_len <span style="color:#000;font-weight:bold">||</span> localip<span style="color:#000;font-weight:bold">-&gt;</span>ip_id <span style="color:#000;font-weight:bold">!=</span> ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_id) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* new (or different) packet, reset structs */</span>
</span></span><span style="display:flex;"><span>		total_len <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0xffff</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].last_byte <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">~</span><span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].next_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].prev_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		first_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* any IP header will work, copy the first we received */</span>
</span></span><span style="display:flex;"><span>		memcpy(localip, ip, IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * What follows is the reassembly algorithm. We use the payload
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * array as a linked list of hole descriptors, as each hole starts
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * at a multiple of 8 bytes. However, last byte can be whatever value,
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * so it is represented as byte count, not as 8-byte blocks.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	h <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> first_hole;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">while</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;</span> start) {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* no hole that far away */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		h <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* last fragment may be 1..7 bytes, the &#34;+7&#34; forces acceptance */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (offset8 <span style="color:#000;font-weight:bold">+</span> ((len <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">7</span>) <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>) <span style="color:#000;font-weight:bold">&lt;=</span> h <span style="color:#000;font-weight:bold">-</span> payload) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* no overlap with holes (dup fragment?) */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>(ip_off <span style="color:#000;font-weight:bold">&amp;</span> IP_FLAGS_MFRAG)) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* no more fragmentss: truncate this (last) hole */</span>
</span></span><span style="display:flex;"><span>		total_len <span style="color:#000;font-weight:bold">=</span> start <span style="color:#000;font-weight:bold">+</span> len;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start <span style="color:#000;font-weight:bold">+</span> len;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * There is some overlap: fix the hole list. This code doesn&#39;t
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * deal with a fragment that overlaps with two different holes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * (thus being a superset of a previously-received fragment).
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> ((h <span style="color:#000;font-weight:bold">&gt;=</span> thisfrag) <span style="color:#000;font-weight:bold">&amp;&amp;</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;=</span> start <span style="color:#000;font-weight:bold">+</span> len)) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* complete overlap with hole: remove hole */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole <span style="color:#000;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* last remaining hole */</span>
</span></span><span style="display:flex;"><span>			done <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* first hole */</span>
</span></span><span style="display:flex;"><span>			first_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* last hole */</span>
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* in the middle of the list */</span>
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole;
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;=</span> start <span style="color:#000;font-weight:bold">+</span> len) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* overlaps with final part of the hole: shorten this hole */</span>
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (h <span style="color:#000;font-weight:bold">&gt;=</span> thisfrag) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* overlaps with initial part of the hole: move this hole */</span>
</span></span><span style="display:flex;"><span>		newh <span style="color:#000;font-weight:bold">=</span> thisfrag <span style="color:#000;font-weight:bold">+</span> (len <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">*</span>newh <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>h;
</span></span><span style="display:flex;"><span>		h <span style="color:#000;font-weight:bold">=</span> newh;
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole)
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole)
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>			first_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* fragment sits in the middle: split the hole */</span>
</span></span><span style="display:flex;"><span>		newh <span style="color:#000;font-weight:bold">=</span> thisfrag <span style="color:#000;font-weight:bold">+</span> (len <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">*</span>newh <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>h;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole <span style="color:#000;font-weight:bold">=</span> (newh <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		newh<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (newh<span style="color:#000;font-weight:bold">-&gt;</span>next_hole)
</span></span><span style="display:flex;"><span>			payload[newh<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> (newh <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* finally copy this fragment and possibly return whole packet */</span>
</span></span><span style="display:flex;"><span>	memcpy((uchar <span style="color:#000;font-weight:bold">*</span>)thisfrag, indata <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE, len); <span style="color:#998;font-style:italic">// ç”±äºlenä¸ºè´Ÿå€¼ï¼Œæ­¤å¤„å‘ç”Ÿæ•´æ•°æº¢å‡ºï¼Œmemcpyé€ æˆæ ˆæº¢å‡º
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>done)
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	localip<span style="color:#000;font-weight:bold">-&gt;</span>ip_len <span style="color:#000;font-weight:bold">=</span> htons(total_len);
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">*</span>lenp <span style="color:#000;font-weight:bold">=</span> total_len <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> localip;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>åŒæ ·æ˜¯å› ä¸ºç›²ä¿¡æ”»å‡»è€…çš„IPæ•°æ®æŠ¥è€Œæœªåšæ ¡éªŒï¼Œé€ æˆçš„æ•´æ•°æº¢å‡ºä¸æ ˆæº¢å‡ºæ¼æ´ã€‚</p>
<h1 id="æ¼æ´å½±å“">æ¼æ´å½±å“</h1>
<p>ç”±gitä»“åº“æŸ¥çœ‹ï¼š</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/u-boot/u-boot.git
</span></span><span style="display:flex;"><span><span style="color:#0086b3">cd</span> u-boot
</span></span><span style="display:flex;"><span>git log net/net.c
</span></span></code></pre></div><p>å¯ä»¥çœ‹åˆ°ä¿®å¤çš„commitï¼š</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>commit b85d130ea0cac152c21ec38ac9417b31d41b5552
</span></span><span style="display:flex;"><span>Author: Fabio Estevam &lt;festevam@denx.de&gt;
</span></span><span style="display:flex;"><span>Date:   Thu May <span style="color:#099">26</span> 11:14:37 <span style="color:#099">2022</span> -0300
</span></span></code></pre></div><p>ç”±æ­¤æ‰¾åˆ°äº†æ¼æ´çš„æœ€æ™šå½±å“ç‰ˆæœ¬ï¼Œé‚£ä¹ˆæœ€æ—©æ˜¯ä»€ä¹ˆæ—¶å€™è¢«å¼•å…¥çš„å‘¢ï¼Ÿ</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git log --follow -p net/net.c
</span></span></code></pre></div><p>ä¸€ç›´å‘å‰å›æº¯<code>__net_defragment</code>çš„å†å²ï¼Œèƒ½æ‰¾åˆ°æœ€æ—©å¼•å…¥è¯¥å‡½æ•°çš„commitï¼š</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>commit 5cfaa4e54d0eb8232fa1cf092d955fdaed5b673d
</span></span><span style="display:flex;"><span>Author: Alessandro Rubini &lt;rubini-list@gnudd.com&gt;
</span></span><span style="display:flex;"><span>Date:   Fri Aug <span style="color:#099">7</span> 13:58:56 <span style="color:#099">2009</span> +0200
</span></span></code></pre></div><p>æ‰€ä»¥è¿™ä¸¤ä¸ªæ¼æ´å½±å“äº†2009/8/7ï½2022/5/26é—´å¼€å¯äº†<code>CONFIG_IP_DEFRAG</code>ç¼–è¯‘é€‰é¡¹çš„U-Bootã€‚</p>
<h1 id="æ¼æ´ä¿®å¤">æ¼æ´ä¿®å¤</h1>
<p>æŸ¥çœ‹ä¿®å¤çš„patchï¼š</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git diff b85d130~ b85d13
</span></span></code></pre></div><p>å¾—åˆ°ï¼š</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#999">diff --git a/include/net.h b/include/net.h
</span></span></span><span style="display:flex;"><span><span style="color:#999">index 675bf4171b..e3889a0bc8 100644
</span></span></span><span style="display:flex;"><span><span style="color:#999"></span><span style="color:#000;background-color:#fdd">--- a/include/net.h
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#fdd"></span><span style="color:#000;background-color:#dfd">+++ b/include/net.h
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd"></span><span style="color:#aaa">@@ -391,6 +391,8 @@ struct ip_hdr {
</span></span></span><span style="display:flex;"><span><span style="color:#aaa"></span>
</span></span><span style="display:flex;"><span> #define IP_HDR_SIZE            (sizeof(struct ip_hdr))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+#define IP_MIN_FRAG_DATAGRAM_SIZE      (IP_HDR_SIZE + 8)
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd"></span> /*
</span></span><span style="display:flex;"><span>  *     Internet Protocol (IP) + UDP header.
</span></span><span style="display:flex;"><span>  */
</span></span><span style="display:flex;"><span><span style="color:#999">diff --git a/net/net.c b/net/net.c
</span></span></span><span style="display:flex;"><span><span style="color:#999">index 034a5d6e67..81905f6315 100644
</span></span></span><span style="display:flex;"><span><span style="color:#999"></span><span style="color:#000;background-color:#fdd">--- a/net/net.c
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#fdd"></span><span style="color:#000;background-color:#dfd">+++ b/net/net.c
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd"></span><span style="color:#aaa">@@ -907,6 +907,9 @@ static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
</span></span></span><span style="display:flex;"><span><span style="color:#aaa"></span>        int offset8, start, len, done = 0;
</span></span><span style="display:flex;"><span>        u16 ip_off = ntohs(ip-&gt;ip_off);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+       if (ip-&gt;ip_len &lt; IP_MIN_FRAG_DATAGRAM_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+               return NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd"></span>        /* payload starts after IP header, this fragment is in there */
</span></span><span style="display:flex;"><span>        payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>        offset8 =  (ip_off &amp; IP_OFFS);
</span></span></code></pre></div><p>æ—¢ç„¶ä¸¤ä¸ªæ¼æ´éƒ½æ˜¯ç”±ç›²ä¿¡æ”»å‡»è€…IPæ•°æ®æŠ¥ä¸­çš„ip-&gt;ip_lené€ æˆçš„ï¼Œé‚£ä¹ˆä¿®å¤æ–¹æ¡ˆå°±å¯¹å…¶åšä¸ªæ ¡éªŒå°±å¥½å•¦ã€‚</p>
<p>ä¿®å¤ä»£ç å°±æ˜¯æ·»åŠ é™åˆ¶ï¼š<code>ip-&gt;ip_len &gt;= IP_HDR_SIZE + 8</code></p>
</div>
  
</article>
<button class="floating-button">
    <a class="floating-button__link" href="https://cerr.cc/">
        <span style="font-size: large; font-family: monospace; font-weight: bolder;">~</span>
    </a>
</button>


    </div>
    
    <footer class="post-footer">
    <div class="footer">
        
            <div>Â© 2022, Zikey Vi</div>
        
        <div class="footer__socials">


<a
  href="mailto:dev2ero@foxmail.com"
  target="_blank"
  class="social-link"
  rel="noopener"
>
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Gmail</title><path d="M24 5.457v13.909c0 .904-.732 1.636-1.636 1.636h-3.819V11.73L12 16.64l-6.545-4.91v9.273H1.636A1.636 1.636 0 0 1 0 19.366V5.457c0-2.023 2.309-3.178 3.927-1.964L5.455 4.64 12 9.548l6.545-4.91 1.528-1.145C21.69 2.28 24 3.434 24 5.457z"/></svg>
</a>&nbsp;&nbsp;



<a
  href="https://github.com/dev2ero"
  target="_blank"
  class="social-link"
  rel="noopener"
>
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
</a>&nbsp;&nbsp;



<a
  href="https://twitter.com/dev2ero"
  target="_blank"
  class="social-link"
  rel="noopener"
>
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg>
</a>&nbsp;&nbsp;



<a
  href="https://space.bilibili.com/210892014"
  target="_blank"
  class="social-link"
  rel="noopener"
>
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Bilibili</title><path d="M17.813 4.653h.854c1.51.054 2.769.578 3.773 1.574 1.004.995 1.524 2.249 1.56 3.76v7.36c-.036 1.51-.556 2.769-1.56 3.773s-2.262 1.524-3.773 1.56H5.333c-1.51-.036-2.769-.556-3.773-1.56S.036 18.858 0 17.347v-7.36c.036-1.511.556-2.765 1.56-3.76 1.004-.996 2.262-1.52 3.773-1.574h.774l-1.174-1.12a1.234 1.234 0 0 1-.373-.906c0-.356.124-.658.373-.907l.027-.027c.267-.249.573-.373.92-.373.347 0 .653.124.92.373L9.653 4.44c.071.071.134.142.187.213h4.267a.836.836 0 0 1 .16-.213l2.853-2.747c.267-.249.573-.373.92-.373.347 0 .662.151.929.4.267.249.391.551.391.907 0 .355-.124.657-.373.906zM5.333 7.24c-.746.018-1.373.276-1.88.773-.506.498-.769 1.13-.786 1.894v7.52c.017.764.28 1.395.786 1.893.507.498 1.134.756 1.88.773h13.334c.746-.017 1.373-.275 1.88-.773.506-.498.769-1.129.786-1.893v-7.52c-.017-.765-.28-1.396-.786-1.894-.507-.497-1.134-.755-1.88-.773zM8 11.107c.373 0 .684.124.933.373.25.249.383.569.4.96v1.173c-.017.391-.15.711-.4.96-.249.25-.56.374-.933.374s-.684-.125-.933-.374c-.25-.249-.383-.569-.4-.96V12.44c0-.373.129-.689.386-.947.258-.257.574-.386.947-.386zm8 0c.373 0 .684.124.933.373.25.249.383.569.4.96v1.173c-.017.391-.15.711-.4.96-.249.25-.56.374-.933.374s-.684-.125-.933-.374c-.25-.249-.383-.569-.4-.96V12.44c.017-.391.15-.711.4-.96.249-.249.56-.373.933-.373Z"/></svg>
</a>

</div>
    </div>
</footer>


    
    
      
<script src="https://cerr.cc/js/script.js"></script>

    
  </body>
</html>
