---
title: "å¯¹U-Boot CVE-2022-30790çš„è·Ÿè¸ª"
description: "ä»¥åŠCVE-2022-30552"
date: 2022-06-16T10:11:14+08:00
categories: "æ¼æ´åˆ†æ"
tags: [ "Coreutils" ]
image: "https://s2.loli.net/2022/06/16/R9KWInUb6Cdyhl2.jpg"
---



## U-Booté€Ÿè§ˆ

- [Das U-Boot - Wikipedia](https://en.wikipedia.org/wiki/Das_U-Boot)
- [https://github.com/u-boot/u-boot](https://github.com/u-boot/u-boot)
- [U-Bootæºç åœ¨çº¿æµè§ˆ](https://elixir.bootlin.com/u-boot/latest/source)



## æ‘ä¸­ä¼ è¨€

**[https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/](https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/)**

ğŸ¤”Hmmm...æ–°é²œæ¼æ´ï¼Œæ²¡æœ‰PoCã€‚è¿™æ¬¡æ˜¯å‡ºäº†ä¸¤ä¸ªæ¼æ´ï¼Œåˆ†åˆ«æ˜¯ï¼š

- Hole Descriptor Overwrite in U-Boot IP Packet Defragmentation Leads to Arbitrary Out of Bounds Write Primitive ([CVE-2022-30790](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30790))
- Large buffer overflow leads to DoS in U-Boot IP Packet Defragmentation Code ([CVE-2022-30552](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30552))

å…ˆæ¥åˆ†æåˆ†æå‡ºç°æ¼æ´çš„æºç ã€‚æ ¹æ®ï¼š

> **May 18th 2022:** Initial e-mail from NCC to U-boot maintainers announcing two vulnerabilities were identified. 

é‚£ä¹ˆç”¨U-Boot v2022.04è·Ÿè¸ªæ¼æ´åº”è¯¥æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚



## æ¼æ´æºç åˆ†æ

### CVE-2022-30790

æ¼æ´å½±å“ï¼š

> The U-Boot implementation of [RFC815](https://datatracker.ietf.org/doc/html/rfc815) IP DATAGRAM REASSEMBLY ALGORITHMS is susceptible to a Hole Descriptor overwrite attack which ultimately leads to an arbitrary write primitive.

#### RFC815

çœ‹æ¥éœ€è¦å…ˆäº†è§£ä¸‹RFC815çš„IPv4åˆ†ç‰‡ç®—æ³•ï¼š

- åŸæ–‡æ¡£ï¼š[https://datatracker.ietf.org/doc/html/rfc815](https://datatracker.ietf.org/doc/html/rfc815)
- ä¸€ç¯‡ç›¸å…³è®ºæ–‡ï¼š[http://www.ecice06.com/CN/Y2008/V34/I22/100](http://www.ecice06.com/CN/Y2008/V34/I22/100)

> RFC815 æ˜¯ IETF æ¨èçš„ä¸€ç§åˆ†ç‰‡é‡ç»„ç®—æ³•ï¼Œè¯¥ç®—æ³•å…·æœ‰è®°å½•åˆ†ç‰‡ç®€æ´ï¼Œå†…å­˜éœ€æ±‚é‡ä¸åŸ IPv4 æ•°æ®æŠ¥å¤§å°ä¸€è‡´ç­‰ä¼˜ç‚¹ã€‚

è¯¥ç®—æ³•çš„ä½œç”¨å¯¹è±¡æ˜¯IPv4æ•°æ®æŠ¥ã€‚IPv4æ•°æ®æŠ¥çš„Headerç»“æ„å¦‚ä¸‹ï¼š(ref - [https://en.wikipedia.org/wiki/IPv4](https://en.wikipedia.org/wiki/IPv4)

![image.png](https://s2.loli.net/2022/06/16/nlCgH1URZ7uXwQ3.png)

å…¶ä¸­ï¼Œåˆ†ç‰‡ä¿¡æ¯è®°å½•åœ¨ï¼š

- **Identification**

    - This field is an identification field and is primarily used for uniquely identifying the group of fragments of a single IP datagram. Some experimental work has suggested using the ID field for other purposes, such as for adding packet-tracing information to help trace datagrams with spoofed source addresses, but RFC 6864 now prohibits any such use.

- **Flags**

    - A three-bit field follows and is used to control or identify fragments. They are (in order, from most significant to least significant):

        - bit 0: Reserved; must be zero
        - bit 1: Don't Fragment (DF)
        - bit 2: More Fragments (MF)

        If the DF flag is set, and fragmentation is required to route the packet, then the packet is dropped. This can be used when sending packets to a host that does not have resources to perform reassembly of fragments. It can also be used for [path MTU discovery](https://en.wikipedia.org/wiki/Path_MTU_discovery), either automatically by the host IP software, or manually using diagnostic tools such as [ping](https://en.wikipedia.org/wiki/Ping_(networking_utility)) or [traceroute](https://en.wikipedia.org/wiki/Traceroute).

        For unfragmented packets, the MF flag is cleared. For fragmented packets, all fragments except the last have the MF flag set. The last fragment has a non-zero Fragment Offset field, differentiating it from an unfragmented packet.

- **Fragment Offset**

    - This field specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram **in units of eight-byte blocks**. The first fragment has an offset of zero. The 13 bit field allows a maximum offset of (2<sup>13</sup> â€“ 1) Ã— 8 = 65,528 bytes, which, with the header length included (65,528 + 20 = 65,548 bytes), supports fragmentation of packets exceeding the maximum IP length of 65,535 bytes.

æ³¨æ„åˆ°åˆ†ç‰‡çš„ç´¢å¼•å•ä½ä¸º8å­—èŠ‚ã€‚

å¥½äº†ï¼Œç®€å•äº†è§£è¿‡æ•°æ®ç»“æ„ï¼Œæ¥ç€æ¥çœ‹çœ‹ç®—æ³•ã€‚

åŸæ–‡æ¡£æœ‰è¨€ï¼š

> One of the mechanisms of IP is fragmentation and reassembly.
>
> åˆ†ç‰‡å’Œé‡ç»„æ˜¯IPv4åè®®çš„ä¸€ä¸ªæœºåˆ¶ã€‚(æ–‡æ¡£å¾ˆè€ï¼Œé‚£æ—¶è¿˜æ²¡æœ‰IPv6ã€‚In contrast, [IPv6](https://en.wikipedia.org/wiki/IPv6), the next generation of the Internet Protocol, does not allow routers to perform fragmentation; hosts must perform [Path MTU Discovery](https://en.wikipedia.org/wiki/Path_MTU_Discovery) before sending datagrams.)

> A  datagram originally transmitted as a single unit will arrive at its final destination broken into several fragments.
>
> ä¸€ä¸ªæ•°æ®æŠ¥â€”â€”ä½œä¸ºä¼ è¾“åŸºæœ¬å•å…ƒï¼Œä¼šè¢«åˆ‡åˆ†ä¸ºå¤šä¸ªåˆ†ç‰‡é€è¾¾æœ€ç»ˆçš„ç›®çš„åœ°ã€‚

è€ŒRFC815æ‰€å®šä¹‰çš„ï¼Œæ­£æ˜¯**reassemblyâ€”â€”åˆ†ç‰‡é‡ç»„**è¿™ä¸€æ­¥çš„å…·ä½“å®ç°ç®—æ³•ã€‚

> In  order  to  define this reassembly algorithm, it is necessary to define some terms. 
>
> A partially reassembled datagram consists of certain sequences of octets that have already arrived, and certain  areas  still to  come.

> We will refer to these missing areas as **"holes"**.
>
> Each hole can be characterized by two numbers:
>
> - **hole.first**
>     - the number of the first octet in the hole
> - **hole.last**
>     - the number of the last  octet  in  the hole
>
> This pair of numbers we will call the **"hole descriptor"**, 
>
> and we will assume that all of the hole descriptors for a  particular  datagram are gathered together in the **"hole descriptor list"**.

æ€»ä½“æ¥è¯´:

> The  general  form  of  the  algorithm  is  as follows.
>
> When a new fragment of the datagram arrives, it will possibly fill in one  or  more of  the existing holes.
>
> We will examine each of the entries in the hole descriptor list to see whether the hole in  question  is  eliminated  by this incoming fragment.
>
> If so, we will delete that entry from the list.
>
> Eventually, a fragment will arrive which eliminates every entry from the list.
>
> At this point, the datagram has been completely reassembled and can be passed to higher protocol levels for further processing.

å…·ä½“çš„ç®—æ³•å®ç°è¦åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š

é¦–å…ˆæ˜¯**Fragment Processing Algorithm**

> We  start  the algorithm when the earliest fragment of the datagram arrives.  We begin by creating an empty data buffer area and putting one entry in its  hole  descriptor  list,  the  entry  which  describes  the datagram  as  being completely missing.  In this case, hole.first equals zero, and hole.last equals infinity. (Infinity is presumably implemented by a very large integer, greater than 576, of the implementor's choice.) The following eight steps are then used to insert each of  the  arriving fragments  into  the  buffer  area  where the complete datagram is being built up.  The arriving fragment is  described  by  fragment.first,  the first  octet  of  the fragment, and fragment.last, the last octet of the fragment.

æ¥ç€è¿›è¡Œå¦‚ä¸‹æµç¨‹ï¼š

1. Select the next hole  descriptor  from  the  hole  descriptor list.  If there are no more entries, go to step eight.
 2. If fragment.first is greater than hole.last, go to step one.
 2. If fragment.last is less than hole.first, go to step one.
 2. Delete the current entry from the hole descriptor list.
 2. If fragment.first is greater than hole.first, then  create  a new  hole  descriptor "new_hole" with new_hole.first equal to hole.first, and new_hole.last equal to  fragment.first  minus one.
 2. If fragment.last is less  than  hole.last  and  fragment.more fragments   is  true,  then  create  a  new  hole  descriptor "new_hole", with new_hole.first equal to  fragment.last  plus one and new_hole.last equal to hole.last.
 2. Go to step one.
 2. If the hole descriptor list is now empty, the datagram is now complete.  Pass it on to the higher level protocol  processor for further handling. Otherwise, return.

ç®—æ³•çš„ç¬¬äºŒéƒ¨åˆ†æ˜¯**Managing the Hole Descriptor List**

å…¶ä¸­æœ‰è§„åˆ™ï¼š

> Just put each hole descriptor in the first octets of  the  hole  itself. 
>
> å°†holeçš„æè¿°ç¬¦ç½®äºholeçš„å‰å…«ä¸ªå­—èŠ‚ä½ç½®å³å¯ã€‚
>
> Note  that by the definition of the reassembly algorithm, the minimum size of  a  hole  is  eight  octets.
>
> To  store hole.first  and  hole.last  will presumably require two octets each.  
>
> An additional two octets will be required to thread together the entries on the hole descriptor list.  
>
> This leaves at least two more octets to  dealwith implementation idiosyncrasies.

holeçš„æœ€å°å¤§å°æ˜¯8å­—èŠ‚ã€‚å¤§å°å’ŒU-Bootçš„å®ç°æ˜¯å¥‘åˆçš„ï¼š

```c
/*
 * this is the packet being assembled, either data or frag control.
 * Fragments go by 8 bytes, so this union must be 8 bytes long
 */
struct hole {
	/* first_byte is address of this structure */
	u16 last_byte;	/* last byte in this hole + 1 (begin of next hole) */
	u16 next_hole;	/* index of next (in 8-b blocks), 0 == none */
	u16 prev_hole;	/* index of prev, 0 == none */
	u16 unused;
};
```

ä½†å†…å®¹æœ‰äº›ä¸åŒï¼šU-Bootçš„å®ç°å¹¶ä¸åŒ…å«`hole.first`åŸŸï¼Œå› ä¸º first_byte is address of this structure.

ç”±æ­¤çœ‹æ¥ï¼Œè¿™é‡Œçš„å†…å­˜ç®¡ç†æ–¹å¼ç±»ä¼¼äºGlibcå †å†…å­˜ç®¡ç†æ–¹æ¡ˆã€‚ç”¨åŒå‘é“¾è¡¨ç®¡ç†äº†ç©ºé—²åŒºåŸŸï¼ˆholeã€free chunkï¼‰ï¼Œä¸”åœ¨ç©ºé—²åŒºåŸŸå†…éƒ¨è®°å½•è‡ªå·±çš„ç›¸å…³ä¿¡æ¯ï¼Œæœ€å°å¤§å°ä¸ºè‡ªèº«æ§åˆ¶åŸŸï¼ˆ8-Bytes struct holeã€free chunk headerï¼‰ï¼Œå¹¶ç»„æˆåŒå‘é“¾è¡¨ç”¨äºé«˜æ•ˆæ£€ç´¢ã€‚ä½†ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œholeä¹‹é—´ç»„æˆçš„é“¾è¡¨ï¼Œæ˜¯å€Ÿç”±å­—èŠ‚ç´¢å¼•è€ŒéæŒ‡é’ˆå®ç°çš„ã€‚

#### å¼€å§‹åˆ†æ

æ¼æ´ä½ç½®ï¼š

> In `u-boot/net/net.c` the `__net_defragment` function line 900 through 1018.

æ¼æ´æºç ï¼š

[https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900](https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900)

defragmentå³reassemblyçš„æ“ä½œï¼Œåˆå¹¶åˆ†ç‰‡ã€‚æ³¨é‡Šä¸åˆ†æå¦‚ä¸‹ï¼š

```c
static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
{
	static uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN); // packet_buffer ip_packet_size packet_align
	static u16 first_hole, total_len;
	struct hole *payload, *thisfrag, *h, *newh; // payload this_fragment hole new_hole
	struct ip_udp_hdr *localip = (struct ip_udp_hdr *)pkt_buff;
	uchar *indata = (uchar *)ip;
	int offset8, start, len, done = 0;
	u16 ip_off = ntohs(ip->ip_off);

	/* payload starts after IP header, this fragment is in there */
	payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
	offset8 =  (ip_off & IP_OFFS); // IP_OFFS 0x1fff 0b0001111111111111ï¼Œåˆ†ç‰‡ç´¢å¼•çš„åŸºæœ¬å•ä½ä¸º8å­—èŠ‚
	thisfrag = payload + offset8; // å½“å‰åˆ†ç‰‡çš„ç´¢å¼•ï¼ˆ8å­—èŠ‚ï¼‰
	start = offset8 * 8; // å½“å‰åˆ†ç‰‡çš„å­—èŠ‚ç´¢å¼•
	len = ntohs(ip->ip_len) - IP_HDR_SIZE; // æ”»å‡»è€…é€šè¿‡æ„é€ æ¶æ„æ•°æ®åŒ…ï¼Œå°†ip->ip_lenæ§åˆ¶åœ¨21~27ï¼Œä½¿å¾—lenä¸º1~7çš„å€¼ï¼Œè§¦å‘åç»­æ¼æ´

	if (start + len > IP_MAXUDP) /* fragment extends too far */
		return NULL;

	if (!total_len || localip->ip_id != ip->ip_id) { // group of fragments of a single IP datagramä¸åŒï¼Œæ„å‘³ç€æ–°æ¥çš„åˆ†ç‰‡ä¸å±äºåŒä¸€æ•°æ®æŠ¥
		/* new (or different) packet, reset structs */
		total_len = 0xffff;
		payload[0].last_byte = ~0;
		payload[0].next_hole = 0;
		payload[0].prev_hole = 0;
		first_hole = 0;
		/* any IP header will work, copy the first we received */
		memcpy(localip, ip, IP_HDR_SIZE);
	}

    // æ­¤åå°±æ˜¯å…·ä½“çš„reassemblyç®—æ³•å®ç°äº†
	/*
	 * What follows is the reassembly algorithm. We use the payload
	 * array as a linked list of hole descriptors, as each hole starts
	 * at a multiple of 8 bytes. However, last byte can be whatever value,
	 * so it is represented as byte count, not as 8-byte blocks.
	 */

	h = payload + first_hole;
	while (h->last_byte < start) {
		if (!h->next_hole) {
			/* no hole that far away */
			return NULL;
		}
		h = payload + h->next_hole;
	}

	/* last fragment may be 1..7 bytes, the "+7" forces acceptance */
	if (offset8 + ((len + 7) / 8) <= h - payload) {
		/* no overlap with holes (dup fragment?) */
		return NULL;
	}

	if (!(ip_off & IP_FLAGS_MFRAG)) {
		/* no more fragmentss: truncate this (last) hole */
		total_len = start + len;
		h->last_byte = start + len;
	}

	/*
	 * There is some overlap: fix the hole list. This code doesn't
	 * deal with a fragment that overlaps with two different holes
	 * (thus being a superset of a previously-received fragment).
	 */

	if ((h >= thisfrag) && (h->last_byte <= start + len)) {
		/* complete overlap with hole: remove hole */
		if (!h->prev_hole && !h->next_hole) {
			/* last remaining hole */
			done = 1;
		} else if (!h->prev_hole) {
			/* first hole */
			first_hole = h->next_hole;
			payload[h->next_hole].prev_hole = 0;
		} else if (!h->next_hole) {
			/* last hole */
			payload[h->prev_hole].next_hole = 0;
		} else {
			/* in the middle of the list */
			payload[h->next_hole].prev_hole = h->prev_hole;
			payload[h->prev_hole].next_hole = h->next_hole;
		}

	} else if (h->last_byte <= start + len) {
		/* overlaps with final part of the hole: shorten this hole */
		h->last_byte = start;

	} else if (h >= thisfrag) {
		/* overlaps with initial part of the hole: move this hole */
		newh = thisfrag + (len / 8); // è®¡ç®—new_holeçš„åˆ†ç‰‡ç´¢å¼•å€¼ã€‚lenä¸º1~7çš„å€¼æ—¶ï¼Œä¼šå¯¼è‡´æ­¤å¤„ newh == thisfrag
		*newh = *h;
		h = newh;
		if (h->next_hole)
			payload[h->next_hole].prev_hole = (h - payload);
		if (h->prev_hole)
			payload[h->prev_hole].next_hole = (h - payload);
		else
			first_hole = (h - payload);

	} else {
		/* fragment sits in the middle: split the hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h->last_byte = start;
		h->next_hole = (newh - payload);
		newh->prev_hole = (h - payload);
		if (newh->next_hole)
			payload[newh->next_hole].prev_hole = (newh - payload);
	}

	/* finally copy this fragment and possibly return whole packet */
	memcpy((uchar *)thisfrag, indata + IP_HDR_SIZE, len); /* è¿™é‡Œå‘this_fragmentä¸­å†™å…¥æ”»å‡»è€…å¯æ§çš„æ•°æ®ï¼Œ
							ä½†ç”±äº newh == thisfragï¼Œé€ æˆnew_holeä¸­çš„æ§åˆ¶æ•°æ®è¢«ç¯¡æ”¹ï¼ˆç±»ä¼¼äºfree chunk headerè¢«ç¯¡æ”¹ï¼‰ã€‚
							ä¸”å½“lenä¸º6æ—¶ï¼Œfirst_holeä¸­çš„last_byteã€next_holeã€prev_holeéƒ½è¢«æ”»å‡»è€…æ§åˆ¶ï¼Œ
							ç”±æ­¤ï¼Œæ”»å‡»è€…é€šè¿‡åŠ«æŒholeçš„ä½ç½®ç´¢å¼•ï¼Œé€ æˆä»»æ„åœ°å€å†™ã€‚*/
	if (!done)
		return NULL;

	localip->ip_len = htons(total_len);
	*lenp = total_len + IP_HDR_SIZE;
	return localip;
}
```

æ‰€ä»¥å®é™…ä¸Šæ˜¯ä¸€ä¸ªï¼šç›²ç›®ä¿¡ä»»ç”¨æˆ·ä¼ å…¥çš„IPæ•°æ®æŠ¥ä¸­çš„`ip_len`å­—æ®µï¼Œé€ æˆholeç»“æ„è¢«åŠ«æŒï¼Œè€Œå¯¼è‡´çš„æ•°ç»„è¶Šç•Œå†™æ¼æ´ã€‚

ç”±æ­¤è¾¾æˆçš„ä»»æ„åœ°å€å†™å¯ä»¥ç”¨äºrootæœ¬åœ°è®¾å¤‡ã€‚ä½†ç”±äºè·¯ç”±å™¨å¾€å¾€ä¼šå¯¹ç»è¿‡è‡ªå·±çš„æ•°æ®åŒ…åˆæ³•æ€§åšæ ¡éªŒå¹¶ä¸¢å¼ƒéæ³•æ•°æ®æŠ¥ï¼Œå¯¼è‡´æ­¤æ¼æ´éš¾ä»¥äºäº’è”ç½‘ä¸Šåˆ©ç”¨ã€‚



### CVE-2022-30552

æ¼æ´å‡ºç°ä½ç½®å’Œä¸Šä¸ªæ¼æ´ç›¸åŒ

```c
static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
{
	static uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN);
	static u16 first_hole, total_len;
	struct hole *payload, *thisfrag, *h, *newh;
	struct ip_udp_hdr *localip = (struct ip_udp_hdr *)pkt_buff;
	uchar *indata = (uchar *)ip;
	int offset8, start, len, done = 0;
	u16 ip_off = ntohs(ip->ip_off);

	/* payload starts after IP header, this fragment is in there */
	payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
	offset8 =  (ip_off & IP_OFFS);
	thisfrag = payload + offset8;
	start = offset8 * 8;
	len = ntohs(ip->ip_len) - IP_HDR_SIZE; // ip->ip_lenç”±æ”»å‡»è€…æ§åˆ¶ï¼Œå°†å…¶è®¾å®šä¸ºå°äºIP_HDR_SIZEçš„å€¼ä¼šä½¿å¾—lenä¸ºè´Ÿå€¼

	if (start + len > IP_MAXUDP) /* fragment extends too far */
		return NULL;

	if (!total_len || localip->ip_id != ip->ip_id) {
		/* new (or different) packet, reset structs */
		total_len = 0xffff;
		payload[0].last_byte = ~0;
		payload[0].next_hole = 0;
		payload[0].prev_hole = 0;
		first_hole = 0;
		/* any IP header will work, copy the first we received */
		memcpy(localip, ip, IP_HDR_SIZE);
	}

	/*
	 * What follows is the reassembly algorithm. We use the payload
	 * array as a linked list of hole descriptors, as each hole starts
	 * at a multiple of 8 bytes. However, last byte can be whatever value,
	 * so it is represented as byte count, not as 8-byte blocks.
	 */

	h = payload + first_hole;
	while (h->last_byte < start) {
		if (!h->next_hole) {
			/* no hole that far away */
			return NULL;
		}
		h = payload + h->next_hole;
	}

	/* last fragment may be 1..7 bytes, the "+7" forces acceptance */
	if (offset8 + ((len + 7) / 8) <= h - payload) {
		/* no overlap with holes (dup fragment?) */
		return NULL;
	}

	if (!(ip_off & IP_FLAGS_MFRAG)) {
		/* no more fragmentss: truncate this (last) hole */
		total_len = start + len;
		h->last_byte = start + len;
	}

	/*
	 * There is some overlap: fix the hole list. This code doesn't
	 * deal with a fragment that overlaps with two different holes
	 * (thus being a superset of a previously-received fragment).
	 */

	if ((h >= thisfrag) && (h->last_byte <= start + len)) {
		/* complete overlap with hole: remove hole */
		if (!h->prev_hole && !h->next_hole) {
			/* last remaining hole */
			done = 1;
		} else if (!h->prev_hole) {
			/* first hole */
			first_hole = h->next_hole;
			payload[h->next_hole].prev_hole = 0;
		} else if (!h->next_hole) {
			/* last hole */
			payload[h->prev_hole].next_hole = 0;
		} else {
			/* in the middle of the list */
			payload[h->next_hole].prev_hole = h->prev_hole;
			payload[h->prev_hole].next_hole = h->next_hole;
		}

	} else if (h->last_byte <= start + len) {
		/* overlaps with final part of the hole: shorten this hole */
		h->last_byte = start;

	} else if (h >= thisfrag) {
		/* overlaps with initial part of the hole: move this hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h = newh;
		if (h->next_hole)
			payload[h->next_hole].prev_hole = (h - payload);
		if (h->prev_hole)
			payload[h->prev_hole].next_hole = (h - payload);
		else
			first_hole = (h - payload);

	} else {
		/* fragment sits in the middle: split the hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h->last_byte = start;
		h->next_hole = (newh - payload);
		newh->prev_hole = (h - payload);
		if (newh->next_hole)
			payload[newh->next_hole].prev_hole = (newh - payload);
	}

	/* finally copy this fragment and possibly return whole packet */
	memcpy((uchar *)thisfrag, indata + IP_HDR_SIZE, len); // ç”±äºlenä¸ºè´Ÿå€¼ï¼Œæ­¤å¤„å‘ç”Ÿæ•´æ•°æº¢å‡ºï¼Œmemcpyé€ æˆæ ˆæº¢å‡º
	if (!done)
		return NULL;

	localip->ip_len = htons(total_len);
	*lenp = total_len + IP_HDR_SIZE;
	return localip;
}
```

åŒæ ·æ˜¯å› ä¸ºç›²ä¿¡æ”»å‡»è€…çš„IPæ•°æ®æŠ¥è€Œæœªåšæ ¡éªŒï¼Œé€ æˆçš„æ•´æ•°æº¢å‡ºä¸æ ˆæº¢å‡ºæ¼æ´ã€‚



## æ¼æ´å½±å“

ç”±gitä»“åº“æŸ¥çœ‹ï¼š

```sh
git clone https://github.com/u-boot/u-boot.git
cd u-boot
git log net/net.c
```

å¯ä»¥çœ‹åˆ°ä¿®å¤çš„commitï¼š

```sh
commit b85d130ea0cac152c21ec38ac9417b31d41b5552
Author: Fabio Estevam <festevam@denx.de>
Date:   Thu May 26 11:14:37 2022 -0300
```

ç”±æ­¤æ‰¾åˆ°äº†æ¼æ´çš„æœ€æ™šå½±å“ç‰ˆæœ¬ï¼Œé‚£ä¹ˆæœ€æ—©æ˜¯ä»€ä¹ˆæ—¶å€™è¢«å¼•å…¥çš„å‘¢ï¼Ÿ

```sh
git log --follow -p net/net.c
```

ä¸€ç›´å‘å‰å›æº¯`__net_defragment`çš„å†å²ï¼Œèƒ½æ‰¾åˆ°æœ€æ—©å¼•å…¥è¯¥å‡½æ•°çš„commitï¼š

```sh
commit 5cfaa4e54d0eb8232fa1cf092d955fdaed5b673d
Author: Alessandro Rubini <rubini-list@gnudd.com>
Date:   Fri Aug 7 13:58:56 2009 +0200
```

æ‰€ä»¥è¿™ä¸¤ä¸ªæ¼æ´å½±å“äº†2009/8/7ï½2022/5/26é—´å¼€å¯äº†`CONFIG_IP_DEFRAG`ç¼–è¯‘é€‰é¡¹çš„U-Bootã€‚



## æ¼æ´ä¿®å¤

æŸ¥çœ‹ä¿®å¤çš„patchï¼š

```sh
git diff b85d130~ b85d13
```

å¾—åˆ°ï¼š

```diff
diff --git a/include/net.h b/include/net.h
index 675bf4171b..e3889a0bc8 100644
--- a/include/net.h
+++ b/include/net.h
@@ -391,6 +391,8 @@ struct ip_hdr {

 #define IP_HDR_SIZE            (sizeof(struct ip_hdr))

+#define IP_MIN_FRAG_DATAGRAM_SIZE      (IP_HDR_SIZE + 8)
+
 /*
  *     Internet Protocol (IP) + UDP header.
  */
diff --git a/net/net.c b/net/net.c
index 034a5d6e67..81905f6315 100644
--- a/net/net.c
+++ b/net/net.c
@@ -907,6 +907,9 @@ static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
        int offset8, start, len, done = 0;
        u16 ip_off = ntohs(ip->ip_off);

+       if (ip->ip_len < IP_MIN_FRAG_DATAGRAM_SIZE)
+               return NULL;
+
        /* payload starts after IP header, this fragment is in there */
        payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
        offset8 =  (ip_off & IP_OFFS);
```

æ—¢ç„¶ä¸¤ä¸ªæ¼æ´éƒ½æ˜¯ç”±ç›²ä¿¡æ”»å‡»è€…IPæ•°æ®æŠ¥ä¸­çš„ip->ip_lené€ æˆçš„ï¼Œé‚£ä¹ˆä¿®å¤æ–¹æ¡ˆå°±å¯¹å…¶åšä¸ªæ ¡éªŒå°±å¥½å•¦ã€‚

ä¿®å¤ä»£ç å°±æ˜¯æ·»åŠ é™åˆ¶ï¼š`ip->ip_len >= IP_HDR_SIZE + 8`
