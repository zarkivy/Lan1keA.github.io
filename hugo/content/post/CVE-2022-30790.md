---
title: "å¯¹U-Boot CVE-2022-30790çš„è·Ÿè¸ª"
description: "ä»¥åŠCVE-2022-30552"
date: 2022-06-16T10:11:14+08:00
tags: [ "Vulnerability" ]
imagelink: "https://s2.loli.net/2022/06/16/R9KWInUb6Cdyhl2.jpg"
---



# U-Booté€Ÿè§ˆ

- [Das U-Boot - Wikipedia](https://en.wikipedia.org/wiki/Das_U-Boot)
- [https://github.com/u-boot/u-boot](https://github.com/u-boot/u-boot)
- [U-Bootæºç åœ¨çº¿æµè§ˆ](https://elixir.bootlin.com/u-boot/latest/source)



# æ‘ä¸­ä¼ è¨€

**[https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/](https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/)**

ğŸ¤”Hmmm...æ–°é²œæ¼æ´ï¼Œæ²¡æœ‰PoCã€‚è¿™æ¬¡æ˜¯å‡ºäº†ä¸¤ä¸ªæ¼æ´ï¼Œåˆ†åˆ«æ˜¯ï¼š

- Hole Descriptor Overwrite in U-Boot IP Packet Defragmentation Leads to Arbitrary Out of Bounds Write Primitive ([CVE-2022-30790](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30790))
- Large buffer overflow leads to DoS in U-Boot IP Packet Defragmentation Code ([CVE-2022-30552](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30552))

å…ˆæ¥åˆ†æåˆ†æå‡ºç°æ¼æ´çš„æºç ã€‚æ ¹æ®ï¼š

> **May 18th 2022:** Initial e-mail from NCC to U-boot maintainers announcing two vulnerabilities were identified. 

é‚£ä¹ˆç”¨U-Boot v2022.04åº”è¯¥æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚



# æ¼æ´æºç åˆ†æ

## CVE-2022-30790

æ¼æ´å½±å“ï¼š

> The U-Boot implementation of [RFC815](https://datatracker.ietf.org/doc/html/rfc815) IP DATAGRAM REASSEMBLY ALGORITHMS is susceptible to a Hole Descriptor overwrite attack which ultimately leads to an arbitrary write primitive.

### RFC815

çœ‹æ¥éœ€è¦å…ˆäº†è§£ä¸‹RFC815çš„IPåˆ†ç‰‡ç®—æ³•ï¼š

- åŸæ–‡æ¡£ï¼š[https://datatracker.ietf.org/doc/html/rfc815](https://datatracker.ietf.org/doc/html/rfc815)
- ä¸€ç¯‡ç›¸å…³è®ºæ–‡ï¼š[http://www.ecice06.com/CN/Y2008/V34/I22/100](http://www.ecice06.com/CN/Y2008/V34/I22/100)

> RFC815 æ˜¯ IETF æ¨èçš„ä¸€ç§åˆ†ç‰‡é‡ç»„ç®—æ³•ï¼Œè¯¥ç®—æ³•å…·æœ‰è®°å½•åˆ†ç‰‡ç®€æ´ï¼Œå†…å­˜éœ€æ±‚é‡ä¸åŸ IP æ•°æ®æŠ¥å¤§å°ä¸€è‡´ç­‰ä¼˜ç‚¹ã€‚

è¯¥ç®—æ³•çš„ä½œç”¨å¯¹è±¡æ˜¯IPæ•°æ®æŠ¥ã€‚IPv4æ•°æ®æŠ¥çš„Headerç»“æ„å¦‚ä¸‹ï¼š(ref - [https://en.wikipedia.org/wiki/IPv4](https://en.wikipedia.org/wiki/IPv4)

![image.png](https://s2.loli.net/2022/06/16/nlCgH1URZ7uXwQ3.png)

å…¶ä¸­ï¼Œåˆ†ç‰‡ä¿¡æ¯è®°å½•åœ¨ï¼š

- **Identification**

    - This field is an identification field and is primarily used for uniquely identifying the group of fragments of a single IP datagram. Some experimental work has suggested using the ID field for other purposes, such as for adding packet-tracing information to help trace datagrams with spoofed source addresses, but RFC 6864 now prohibits any such use.

- **Flags**

    - A three-bit field follows and is used to control or identify fragments. They are (in order, from most significant to least significant):

        - bit 0: Reserved; must be zero
        - bit 1: Don't Fragment (DF)
        - bit 2: More Fragments (MF)

        If the DF flag is set, and fragmentation is required to route the packet, then the packet is dropped. This can be used when sending packets to a host that does not have resources to perform reassembly of fragments. It can also be used for [path MTU discovery](https://en.wikipedia.org/wiki/Path_MTU_discovery), either automatically by the host IP software, or manually using diagnostic tools such as [ping](https://en.wikipedia.org/wiki/Ping_(networking_utility)) or [traceroute](https://en.wikipedia.org/wiki/Traceroute).

        For unfragmented packets, the MF flag is cleared. For fragmented packets, all fragments except the last have the MF flag set. The last fragment has a non-zero Fragment Offset field, differentiating it from an unfragmented packet.

- **Fragment Offset**

    - This field specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram in units of eight-byte blocks. The first fragment has an offset of zero. The 13 bit field allows a maximum offset of (2<sup>13</sup> â€“ 1) Ã— 8 = 65,528 bytes, which, with the header length included (65,528 + 20 = 65,548 bytes), supports fragmentation of packets exceeding the maximum IP length of 65,535 bytes.

å¥½äº†ï¼Œç®€å•äº†è§£è¿‡æ•°æ®ç»“æ„ï¼Œæ¥ç€æ¥çœ‹çœ‹ç®—æ³•ã€‚

åŸæ–‡æ¡£æœ‰è¨€ï¼š

> One of the mechanisms of IP is fragmentation and reassembly.
>
> åˆ†ç‰‡å’Œé‡ç»„æ˜¯IPåè®®çš„ä¸€ä¸ªä¸»è¦æœºåˆ¶ã€‚

> A  datagram originally transmitted as a single unit will arrive at its final destination broken into several fragments.
>
> ä¸€ä¸ªæ•°æ®æŠ¥â€”â€”ä½œä¸ºä¼ è¾“åŸºæœ¬å•å…ƒï¼Œä¼šè¢«åˆ‡åˆ†ä¸ºå¤šä¸ªåˆ†ç‰‡é€è¾¾æœ€ç»ˆçš„ç›®çš„åœ°ã€‚





### å¼€å§‹åˆ†æ

æ¼æ´ä½ç½®ï¼š

> In `u-boot/net/net.c` the `__net_defragment` function line 900 through 1018.

æ¼æ´æºç ï¼š

[https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900](https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900)

```c
static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
{
	static uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN);
	static u16 first_hole, total_len;
	struct hole *payload, *thisfrag, *h, *newh;
	struct ip_udp_hdr *localip = (struct ip_udp_hdr *)pkt_buff;
	uchar *indata = (uchar *)ip;
	int offset8, start, len, done = 0;
	u16 ip_off = ntohs(ip->ip_off);

	/* payload starts after IP header, this fragment is in there */
	payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
	offset8 =  (ip_off & IP_OFFS);
	thisfrag = payload + offset8;
	start = offset8 * 8;
	len = ntohs(ip->ip_len) - IP_HDR_SIZE;

	if (start + len > IP_MAXUDP) /* fragment extends too far */
		return NULL;

	if (!total_len || localip->ip_id != ip->ip_id) {
		/* new (or different) packet, reset structs */
		total_len = 0xffff;
		payload[0].last_byte = ~0;
		payload[0].next_hole = 0;
		payload[0].prev_hole = 0;
		first_hole = 0;
		/* any IP header will work, copy the first we received */
		memcpy(localip, ip, IP_HDR_SIZE);
	}

	/*
	 * What follows is the reassembly algorithm. We use the payload
	 * array as a linked list of hole descriptors, as each hole starts
	 * at a multiple of 8 bytes. However, last byte can be whatever value,
	 * so it is represented as byte count, not as 8-byte blocks.
	 */

	h = payload + first_hole;
	while (h->last_byte < start) {
		if (!h->next_hole) {
			/* no hole that far away */
			return NULL;
		}
		h = payload + h->next_hole;
	}

	/* last fragment may be 1..7 bytes, the "+7" forces acceptance */
	if (offset8 + ((len + 7) / 8) <= h - payload) {
		/* no overlap with holes (dup fragment?) */
		return NULL;
	}

	if (!(ip_off & IP_FLAGS_MFRAG)) {
		/* no more fragmentss: truncate this (last) hole */
		total_len = start + len;
		h->last_byte = start + len;
	}

	/*
	 * There is some overlap: fix the hole list. This code doesn't
	 * deal with a fragment that overlaps with two different holes
	 * (thus being a superset of a previously-received fragment).
	 */

	if ((h >= thisfrag) && (h->last_byte <= start + len)) {
		/* complete overlap with hole: remove hole */
		if (!h->prev_hole && !h->next_hole) {
			/* last remaining hole */
			done = 1;
		} else if (!h->prev_hole) {
			/* first hole */
			first_hole = h->next_hole;
			payload[h->next_hole].prev_hole = 0;
		} else if (!h->next_hole) {
			/* last hole */
			payload[h->prev_hole].next_hole = 0;
		} else {
			/* in the middle of the list */
			payload[h->next_hole].prev_hole = h->prev_hole;
			payload[h->prev_hole].next_hole = h->next_hole;
		}

	} else if (h->last_byte <= start + len) {
		/* overlaps with final part of the hole: shorten this hole */
		h->last_byte = start;

	} else if (h >= thisfrag) {
		/* overlaps with initial part of the hole: move this hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h = newh;
		if (h->next_hole)
			payload[h->next_hole].prev_hole = (h - payload);
		if (h->prev_hole)
			payload[h->prev_hole].next_hole = (h - payload);
		else
			first_hole = (h - payload);

	} else {
		/* fragment sits in the middle: split the hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h->last_byte = start;
		h->next_hole = (newh - payload);
		newh->prev_hole = (h - payload);
		if (newh->next_hole)
			payload[newh->next_hole].prev_hole = (newh - payload);
	}

	/* finally copy this fragment and possibly return whole packet */
	memcpy((uchar *)thisfrag, indata + IP_HDR_SIZE, len);
	if (!done)
		return NULL;

	localip->ip_len = htons(total_len);
	*lenp = total_len + IP_HDR_SIZE;
	return localip;
}
```

